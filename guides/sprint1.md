
# Руководство по первому спринту: Верстка компонентов и их тестирование

## 1. Основы работы с GitFlow

### Что такое GitFlow?

GitFlow — это модель ветвления для управления процессом разработки, которая помогает поддерживать структуру проекта в порядке. Основная идея заключается в разделении работы на ветки, каждая из которых имеет свою четкую цель и использование.

### Основные ветки:
1. **Main** — это основная ветка, где всегда находится стабильная версия приложения. Все, что попадает сюда, должно быть полностью протестировано и готово для продакшена.
2. **Develop** — ветка для активной разработки. Все новые фичи после завершения и тестирования сливаются сюда. Это ветка для интеграции функционала.

### Типы временных веток:
1. **Feature** — используется для разработки новых фич. Ветку можно создать командой `git checkout -b feature/<название>` из ветки `develop`. Каждый разработчик ведет свою работу в изолированной ветке, что позволяет избежать конфликтов при параллельной разработке.
   
   **Пример:**
   ```bash
   git checkout -b feature/user-authentication develop
   ```
2. **Release** — создается для подготовки релиза приложения. Используется, когда приложение готово к выпуску, и требуется провести финальные тесты и фиксы.
   
   **Пример:**
   ```bash
   git checkout -b release/1.0 develop
   ```
3. **Hotfix** — создается для быстрого исправления критических ошибок в продакшене. После фикса ветка мержится в `main` и `develop`, чтобы синхронизировать изменения с текущей разработкой.

### Как работать:
1. Создай новую ветку из `develop` для работы над своей задачей (фичей или фиксом).
2. Разработай свою задачу в ветке, периодически коммитя изменения.
3. Когда задача завершена, создавай pull request (PR) для мерджа своей ветки в `develop`.
4. Проведи код-ревью и дождись одобрения.
5. Проверь все тесты и замерджи изменения.

Таким образом, каждый разработчик работает в своей ветке, а ветка `develop` остается местом для интеграции. Это помогает избежать конфликтов и позволяет параллельно работать над разными фичами.

**[Ссылка на документацию GitFlow]**

---

## 2. Архитектура проекта: Feature-Sliced Design

### Что такое Feature-Sliced Design?

Feature-Sliced Design (FSD) — это методология проектирования фронтенд-приложений, которая помогает логически разделять проект на части, чтобы сделать его более гибким, поддерживаемым и масштабируемым.

### Основные принципы:
1. **Feature-ориентированный подход** — каждая фича представляет собой независимый модуль, который отвечает за определенную бизнес-логику.
2. **Слойная архитектура (Layering)** — проект разделен на слои, каждый из которых отвечает за свою конкретную роль в системе:
   - **Application** — содержит бизнес-логику и API.
   - **UI** — пользовательский интерфейс, все визуальные компоненты.
   - **Entities** — сущности данных.
   - **Features** — функциональные компоненты, которые объединяют UI и бизнес-логику.
   - **Shared** — общий код (утилиты, хуки, компоненты), который переиспользуется в разных местах проекта.
   
3. **Минимизация зависимостей** — каждый модуль должен быть максимально независим от других. Это позволяет легко модифицировать отдельные части приложения, не затрагивая весь проект.
4. **Четкая структура директорий** — каждая фича имеет свои файлы (компоненты, стили, тесты) в одной папке, что делает код более организованным.

### Пример структуры папок:
```
src/
│
├── app/                   # инициализация приложения (роутинг, конфигурации)
├── entities/               # сущности (модели данных, стейты)
├── features/               # бизнес-функционал
├── shared/                 # общие компоненты и утилиты
└── ui/                     # визуальные компоненты
```

### Почему это важно?

Feature-Sliced Design позволяет легко разделить ответственность за различные части приложения и облегчить командную разработку. Каждый разработчик может работать в своей зоне, не нарушая архитектуру приложения в целом.

**[Место для ссылки на статью по Feature-Sliced Design]**

---

## 3. Верстка компонентов с Material UI и SCSS

### Организация верстки

1. **Рефакторинг и переиспользование кода**:
   - Стремитесь к максимальной модульности и переиспользованию компонентов.
   - Избегайте дублирования стилей и логики.
   - Например, создавайте компоненты кнопок, инпутов и карточек, которые могут быть использованы в разных частях приложения.

2. **Структура компонентов**:
   - Каждый компонент должен быть максимально изолирован.
   - Разделяйте логику и верстку: например, отдельные файлы для UI-части и бизнес-логики.
   - Используйте SCSS для стилизации, создавая модульные стили (файлы `.module.scss`) для каждого компонента, чтобы избежать конфликтов имен классов.
   
   **Пример структуры компонента**:
   ```
   Button/
   ├── Button.jsx
   ├── Button.module.scss
   └── Button.test.jsx
   ```

3. **Валидация пропсов**:
   - Используйте встроенные в React инструменты валидации пропсов (`PropTypes`), чтобы убедиться, что компоненты работают корректно с разными наборами данных.
   
   **Пример валидации:**
   ```js
   Button.propTypes = {
      color: PropTypes.string.isRequired,
      onClick: PropTypes.func.isRequired,
   };
   ```

4. **Работа с Material UI**:
   - Используйте компоненты Material UI как основу для вашей верстки, адаптируя их под нужды приложения.
   - Стили Material UI можно расширять и изменять с помощью SCSS для кастомизации.

### Разделение задач при верстке:

1. **Компоненты верстает один человек, тестирует другой**. Это необходимо для повышения качества разработки и обеспечения объективного тестирования.
2. **Сложные компоненты могут разрабатываться несколькими людьми**:
   - Например, один человек разрабатывает UI, другой — логику, третий — тесты.
   - Это уменьшает вероятность ошибок и позволяет быстрее завершить разработку.
   
3. **Пример распределения работы**:
   - Один разработчик верстает основную структуру компонента.
   - Другой — пишет логику работы компонента (например, обработчики событий).
   - Тестировщик проверяет компонент на наличие багов, подставляя разные пропсы и проверяя разные сценарии работы.

---

## 4. Тестирование компонентов с Vitest

### Основные моменты тестирования:

1. **Покрытие сценариев**:
   - Каждый компонент должен быть протестирован с различными значениями пропсов, чтобы убедиться в корректности его поведения в разных сценариях.
   - Тесты должны покрывать как успешные сценарии, так и возможные ошибки.

2. **Мока функций и зависимостей**:
   - Если компонент зависит от API или внешних сервисов, используйте мока (mock), чтобы изолировать тестируемый код и протестировать его работу в изоляции.

3. **Snapshot-тесты**:
   - Используйте snapshot-тестирование для проверки рендеринга компонентов. Это поможет вам убедиться, что внешний вид компонентов не изменился при рефакторинге.
   
   **Пример snapshot-теста**:
   ```js
   test('renders correctly', () => {
     const tree = render(<Button color="blue" />);
     expect(tree).toMatchSnapshot();
   });
   ```

### Рекомендации:
- Разрабатывайте тесты параллельно с написанием кода.
- Следите за тем, чтобы покрытие тестами было полным, и тесты были как юнит-, так и интеграционные.
- Используйте Vitest для юнит-тестирования компонентов, чтобы убедиться в их корректной работе.

---

## Заключение

Этот кайт поможет вам начать работу с версткой компонентов и тестированием. Следуйте GitFlow для управления репозиториями, используйте Feature-Sliced Design для организации кода и разбивки проекта на модули. Работайте над компонентами с Material UI и SCSS, учитывая валидацию пропсов и тестирование с разными сценариями. Не забывайте тщательно тестировать компоненты с помощью Vitest, покрывая все возможные случаи их использования.

**[Место для ссылки на дополнительные материалы]**
